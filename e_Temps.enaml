# -*- coding: utf-8 -*-
"""
Created on Sun Jun 28 22:14:19 2015

@author: thomasaref

Collection of user custom member templates for Typed, Instance, members
"""

from enaml.widgets.api import  Field
from atom.api import observe, Coerced, Atom, Callable, Tuple, Typed, Dict, List, Float, Int, Unicode, Enum, Bool, Str, ContainerList, Range, FloatRange, Instance, Event
from enaml.widgets.api import (RawWidget, Container, Field, Form, SpinBox, GroupBox, Label, Window,
                               ProgressBar, PushButton, CheckBox, MultilineField, ScrollArea, ObjectCombo, Slider)

from enaml.layout.api import hbox, vbox, spacer, align
from enaml.core.api import DynamicTemplate, Looper, d_, Include
from enaml.stdlib.fields import FloatField, IntField
from enaml.application import deferred_call

from Atom_Read_File import Read_File
from Atom_Save_File import Save_File
from enaml_Filer import ReadWrap, SaveWrap

from EBL_enaml import EBContWrap
from EBL_Polyer import Polyer

from Atom_Base import get_tag, get_type, Base

template TypedView(base, name, baseType):
    """ This default specialization displays read-only text for the value."""
    Field:
        read_only = True
        text << unicode(getattr(base, name))

def constraints_gen(base, name, lbl, val, unt, contents_width, contents_top, contents_left):
    if type(get_tag(base, name, "width", 0))!=int:
        return [hbox(lbl, val, unt)]
    else:
        return [hbox(lbl, val, unt, spacer), val.width>=get_tag(base, name, 'width', contents_width/5),
                align('bottom', val, unt), align('bottom', lbl, val)]
                 #contents_top == val.top, contents_left == lbl.left,]

template TypedView(base, name, baseType: object):
    IntField:
        value:=getattr(base,name)
template TypedView(base, name, baseType: Base):
    GroupBox:
        flat = True
        padding=0
        constraints = constraints_gen(base, name, lbl, val, unt, contents_width, contents_top, contents_left) #[hbox( lbl, val, unt),#,
        #               align('top', val, unt), align('top', lbl, val),
        #                  align('left', gbcontents, 80, val) | 'medium']#, width == contents_width, height==contents_height]
                        #contents_top == lbl.top, contents_left == lbl.left]#, contents_right == set_params.right,
#                         (lbl.bottom == contents_bottom) | 'medium']
        Label: lbl:
            text = get_tag(base, name, 'label', name)
        Container: val:
            padding = 0
            DynamicTemplate: dyn:
                base = TypedView
                args = (base, name, get_type(base, name))
        Label: unt:
            text = get_tag(base, name, 'unit', "no unit")
            visible = get_tag(base, name, 'unit') is not None

template TypedView(base, name, InstrType: Atom):
    TypedView(base, name, Base):
        pass

template TypedView(base, name, baseType: Read_File):
    """ Displays a read file interface"""
    ReadWrap:
        filer:=getattr(base, name)

template TypedView(base, name, baseType: Save_File):
    """Displays a save file interface"""
    SaveWrap:
        filer:=getattr(base, name)

template TypedView(base, name, baseType: Polyer):
    """Displays a polyer polygon list interface. very ineffecient. too many notifications"""
    EBContWrap:
        polyer:=getattr(base, name)


template TypedView(base, name, baseType: Typed):
    TypedView(base, name, type(getattr(base, name))):
        pass

template TypedView(base, name, baseType: Instance):
    TypedView(base, name, type(getattr(base, name))):
        pass

template TypedView(base, name, baseType: Coerced):
    TypedView(base, name, type(getattr(base, name))):
        pass

template TypedView(base, name, baseType: Float):
    """ A template for Float members"""
    FloatField:
        value :=  getattr(base, name)
        minimum=get_tag(base, name, 'low')
        maximum=get_tag(base, name, 'high')

template TypedView(base, name, baseType: float):
    """ A template for floats"""
    FloatField:
        value :=  getattr(base, name)
        minimum=get_tag(base, name, 'low')
        maximum=get_tag(base, name, 'high')

template TypedView(base, name, baseType: Range):
    """ A template for Range members"""
    Container:
        constraints=[hbox(sel, min_lbl, sel_slider, max_lbl)]
        SpinBox: sel:
            value:=getattr(base, name)
            minimum = sel_slider.minimum
            maximum = sel_slider.maximum
        Slider: sel_slider:
            minimum = base.get_member(name).validate_mode[1][0]
            maximum = base.get_member(name).validate_mode[1][1]
            value :=getattr(base, name)
            tracking = False
        Label: min_lbl:
                text << str(sel_slider.minimum)
        Label: max_lbl:
            text << str(sel_slider.maximum)

#template ValView(base, name, baseType: FloatRange):
#    """ A form control template specialization for Float members"""
#    Container:
#        constraints=[hbox(sel, min_lbl, sel_slider, max_lbl)]
#        FloatField: sel:
#            value:=getattr(base, name)
#            minimum = ft.minimum
#            maximum = ft.maximum
#        Slider: sel_slider:
#            tracking = False
#            FloatTransform: ft:
#                minimum=base.get_tag(name, 'low')
#                maximum=base.get_tag(name, 'high')
#                value :=getattr(base, name)
#                precision=base.get_tag(name, 'precision', 100)
#        Label: min_lbl:
#                text << str(ft.minimum)
#        Label: max_lbl:
#            text << str(ft.maximum)

template TypedView(base, name, baseType: Int):
    """ A template for Int members using a spin box"""
    SpinBox:
        value := getattr(base, name)
        minimum=int(get_tag(base, name, 'low', -2147483648))
        maximum=int(get_tag(base, name, 'high', 2147483647))

template TypedView(base, name, baseType: int):
    """ A template for ints using a spin box"""
    SpinBox:
        value := getattr(base, name)
        minimum=int(get_tag(base, name, 'low', -2147483648))
        maximum=int(get_tag(base, name, 'high', 2147483647))

template TypedView(base, name, baseType: Str):
    """ A template for Str using a MultilineField"""
    MultilineField: mlf:
            text := getattr(base, name)

template TypedView(base, name, baseType: str):
    """ A template for str using a MultilineField"""
    MultilineField: mlf:
            text := getattr(base, name)

template TypedView(base, name, baseType: Unicode):
    """A template for Unicode using a field"""
    Field:
        text := getattr(base, name)

template TypedView(base, name, baseType: unicode):
    """A template for unicode using a field"""
    Field:
        text := getattr(base, name)

def run_params(base, name):
    return getattr(base, name).run_params

template TypedView(base, name, baseType: Callable):
    """A template specialization for a Callable using a PushButton"""
    Container:
        padding = 0
        constraints = [hbox(pb1, gb1), align('top', pb1, gb1)]
        PushButton: pb1:
            text = 'Run'
            clicked :: getattr(instr, name)(instr) #do_it_if_needed(var, "receive") #receive()
            #enabled << not instr.busy
        GroupBox: gb1:
            padding = 0
            visible = run_params(base, name)!=[]
            title = get_tag(base, name, 'label', name)+" parameters:"
            Looper: get_loop:
                    iterable << run_params(base, name)
                    DynamicTemplate:
                        base=VarTemp #text = '{0} {1}'.format(loop_index, loop_item)
                        args=(loop_item, base, type(base))

def get_map(base, name):
    #try:
        return base.get_map(name)
    #except:
    #    return getattr(base, name)

template TypedView(base, name, baseType: Enum):
    """ A form control template specialization for Enum members using ObjectCombo."""
    Container:
        padding = 0
        constraints = [ hbox(val, enm_val)]
        ObjectCombo: val:
            items = list(base.get_member(name).items)
            selected := getattr(base, name)
            selected :: enm_val.text=unicode(get_map(base, name))
        Label: enm_val:
            text =  unicode(get_map(base, name))

template TypedView(base, name, baseType: Bool):
    """ A template specialization for Bool members using CheckBox"""
    CheckBox:
        checked := getattr(base, name)

template TypedView(base, name, baseType: bool):
    """ A template specialization for bools members using CheckBox"""
    CheckBox:
        checked := getattr(base, name)

#template CLView(base, name, index, vtype: Base):
#    AutoFormWrap:
#        instr:=getattr(base, name)[index]
#
#template CLView(base, name, index, vtype):
#    MultilineField:
#        read_only=True
#        text<<unicode(getattr(base, name))
#
##template CLView(base, name, index, vtype: "EMPTY"):
##    pass
#
#template CLView(base, name, index, vtype: float):
#    FloatField:
#        value:=getattr(base, name)[index]
#
#template CLView(base, name, index, vtype: int):
#    IntField:
#        value:=getattr(base, name)[index]
#
#template CLView(base, name, index, vtype: str):
#    """ A template specialization for Unicode using a MultilineField"""
#    MultilineField: mlf:
#            text := getattr(base, name)[index]
#
##template CLView(base, name, index, vtype: list):
##        GroupBox:
##            padding = 0
#            #visible << getattr(base, name)!=[]
#            #title = instr.get_tag(name, 'label', name)+" variables:"
#            #Looper:
#            #        iterable << getattr(base, name) #base.return_vars
#           #         DynamicTemplate:
#           #             base=VarTemp #text = '{0} {1}'.format(loop_index, loop_item)
#           #             args=(loop_item, base, type(base))
#
#template CLView(base, name, index, vtype: unicode):
#    """A template specialization for Unicode using a field"""
#    Field:
#        text := getattr(base, name)[index]
#
#template ClView(base, name, index, vtype: bool):
#    """ A form control template specialization for Bool members using CheckBox"""
#    CheckBox:
#        checked := getattr(base, name)[index]
#
#def get_type(base, name, index):
#    if index<len(getattr(base, name)):
#        print type(getattr(base, name)[index]), base.get_tag(name, "inside_type")
#        return base.get_tag(name, "inside_type", type(getattr(base, name)[index]))
#    return None
#
#template ValView(base, name, baseType: ContainerList):
#    Container:
#        padding=0
#        constraints = [hbox(ind, val, insert_btn, pop_btn), ind.width==100]
#        SpinBox: ind:
#            minimum=0
#            maximum << max(0, len(getattr(base, name))-1)
#        Container: val:
#            padding = 0
#            DynamicTemplate: dyn:
#                base = CLView
#                args << (base, name, ind.value, get_type(base, name, ind.value))
#        PushButton: insert_btn:
#            text="Insert"
#            clicked::
#                if len(getattr(base, name))==0:
#                    intype=base.get_tag(name, 'inside_type')() #if inside_type is not specified for an empty array, this will generate an error
#                else:
#                    temptype=getattr(base, name)[ind.value]
#                    if isinstance(temptype, Base):
#                        intype=temptype.copy()
#                    else:
#                        intype=type(temptype)()
#                getattr(base, name).insert(ind.value, intype) #pass #mydata.insert()
#            #visible << base.get_tag(name, "full_interface", False)
#        PushButton: pop_btn:
#            text="Remove"
#            clicked:: getattr(base, name).pop(ind.value)
#            #visible << base.get_tag(name, "full_interface", False)
#            enabled << len(getattr(base, name))>0
#
#template ValView(base, name, baseType: List):
#        GroupBox:
#            padding = 0
#            visible << getattr(base, name)!=[]
#            title = instr.get_tag(name, 'label', name)+" variables:"
#            Looper:
#                    iterable << getattr(base, name) #base.return_vars
#                    DynamicTemplate:
#                        base=VarTemp #text = '{0} {1}'.format(loop_index, loop_item)
#                        args=(loop_item, base, type(base))
#