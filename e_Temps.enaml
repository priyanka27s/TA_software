# -*- coding: utf-8 -*-
"""
Created on Sun Jun 28 22:14:19 2015

@author: thomasaref

Collection of all member templates. When trying to separate them into other files, it seems to create problems
"""

from atom.api import observe, Coerced, Atom, Callable, Tuple, Typed, Dict, List, Float, Int, Unicode, Enum, Bool, Str, ContainerList, Range, FloatRange, Instance, Event
from enaml.widgets.api import (RawWidget, Container, Field, Form, SpinBox, GroupBox, Label, Window,
                               ProgressBar, PushButton, CheckBox, MultilineField, ScrollArea, ObjectCombo, Slider)

from enaml.layout.api import hbox, vbox, spacer, align
from enaml.core.api import DynamicTemplate, Looper, d_, Include, Conditional
from enaml.stdlib.fields import FloatField, IntField
from enaml.application import deferred_call

from Atom_Read_File import Read_File
from Atom_Save_File import Save_File
from enaml_Filer import ReadWrap, SaveWrap

from EBL_enaml import EBContWrap
from EBL_Polyer import Polyer
from LOG_functions import log_debug
#from e_Instrument import BootClose
from Atom_Instrument import Instrument
from Atom_Base import get_tag, get_type, Base, get_main_params

template TypedView(base, name, baseType):
    """ This default specialization displays read-only text for the value."""
    Field:
        read_only = True
        text << unicode(getattr(base, name))

def constraints_gen(base, name, lbl, val, unt, contents_width, contents_top, contents_left):
    if type(get_tag(base, name, "width", 0))!=int:
        return [hbox(lbl, val, unt)]
    else:
        return [hbox(lbl, val, unt, spacer), val.width>=get_tag(base, name, 'width', contents_width/5),
                align('bottom', val, unt), align('bottom', lbl, val)]
                 #contents_top == val.top, contents_left == lbl.left,]

def form_spec(instr):
    main_params=get_main_params(instr)
    return tuple([(instr, name, get_type(instr, name)) for name in main_params])


template ListView(instrin, name, baseType: Base, Ind):
    BaseView(getattr(instrin, name)[Ind.value], baseType):
        pass


template TypedView(instrin, name, baseType: Base):
    BaseView(getattr(instrin, name), baseType):
        pass

template TypedView(base, name, InstrType: Atom):
    TypedView(base, name, Base):
        pass

template TypedView(base, name, baseType: Read_File):
    """ Displays a read file interface"""
    ReadWrap:
        filer:=getattr(base, name)

template TypedView(base, name, baseType: Save_File):
    """Displays a save file interface"""
    SaveWrap:
        filer:=getattr(base, name)

template TypedView(base, name, baseType: Polyer):
    """Displays a polyer polygon list interface. very ineffecient. too many notifications"""
    EBContWrap:
        polyer:=getattr(base, name)

template TypedView(base, name, baseType: Typed):
    """interface for a Typed member. passes internal type"""
    TypedView(base, name, type(getattr(base, name))):
        pass

template TypedView(base, name, baseType: Instance):
    TypedView(base, name, Typed): pass

template TypedView(base, name, baseType: Coerced):
    TypedView(base, name, Typed): pass

template VarView(instrin, name, baseType):
    GroupBox:
        flat = True
        padding=0
        constraints = constraints_gen(instrin, name, lbl, val, unt, contents_width, contents_top, contents_left) #[hbox( lbl, val, unt),#,
        #               align('top', val, unt), align('top', lbl, val),
        #                  align('left', gbcontents, 80, val) | 'medium']#, width == contents_width, height==contents_height]
                        #contents_top == lbl.top, contents_left == lbl.left]#, contents_right == set_params.right,
#                         (lbl.bottom == contents_bottom) | 'medium']
        Label: lbl:
            text = get_tag(instrin, name, 'label', name)
        Container: val:
            padding = 0
            DynamicTemplate:
                base = TypedView
                args = (instrin, name, baseType) #loop_item
                #data = dict(visible=True)
        Label: unt:
            text = get_tag(instrin, name, 'unit', "no unit")
            visible = get_tag(instrin, name, 'unit') is not None

template BaseView(instrin, baseType):
    Container:
        padding = 0
        Looper:
            iterable<<form_spec(instrin)
            DynamicTemplate:
                base = VarView
                args = loop_item
#                data = dict(visible=True)

template VarView(base, name, InstrType: Instrument):
    GroupBox: contents:
        flat = True
        padding=0
        constraints = [
                        hbox( lbl, val, unt, snd_now, snd, rec, set_params, get_params, spacer),#,
                       align('top', val, rec), align('top', val, unt), align('top', lbl, val),
                         align('top', val, set_params), align('top', set_params, get_params),
                         align('left', contents, 280, rec) | 'medium', align('left', contents, 80, val) | 'medium']
        #                width == contents_width, height==contents_height]
                        #contents_top == lbl.top, contents_left == lbl.left]#, contents_right == set_params.right,
#                         (lbl.bottom == contents_bottom) | 'medium']
        Label: lbl:
            text = instr.get_tag(name, 'label', name)
        Container: val:
            padding = 0
            DynamicTemplate: dyn:
                base = TypedView
                args = (name, instr, instr.get_type(name))
        Label: unt:
            text = instr.get_tag(name, 'unit', "")
            visible = instr.get_tag(name, 'unit')!=None
        GroupBox: get_params:
            padding = 0
            visible = instr.get_run_params(name, 'get_cmd')!=[]
            title = instr.get_tag(name, 'label', name)+" get parameters:"
            Looper: get_loop:
                    iterable << instr.get_run_params(name, 'get_cmd', notself=True)
                    DynamicTemplate:
                        base=VarTemp #text = '{0} {1}'.format(loop_index, loop_item)
                        args=(loop_item, instr, type(instr))

        GroupBox: set_params:
            #hug_height='strong'
            padding = 0
            visible = instr.get_run_params(name, 'set_cmd')!=[]
            title = instr.get_tag(name, 'label', name)+" set parameters:"
            Looper: set_loop:
                    iterable << instr.get_run_params(name, 'set_cmd', notself=True)
                    DynamicTemplate:
                        base=VarTemp #text = '{0} {1}'.format(loop_index, loop_item)
                        args=(loop_item, instr, type(instr))

        CheckBox: snd_now:
            text = 'Send on change'
            checked = instr.get_tag(name, 'send_now', instr.send_now)
            toggled :: instr.set_tag(name, send_now=snd_now.checked)
            visible << (instr.get_tag(name, 'get_cmd')!=None or instr.get_tag(name, 'set_cmd')!=None) and instr.get_tag(name, 'full_interface', instr.full_interface)
        PushButton: snd:
            text = 'Send'
            clicked :: instr.send(name) #sender(var, val)
            enabled << instr.get_tag(name, 'set_cmd')!=None and not instr.busy
            visible << (instr.get_tag(name, 'get_cmd')!=None or instr.get_tag(name, 'set_cmd')!=None) and instr.get_tag(name, 'full_interface', instr.full_interface)
        PushButton: rec:
            text = 'Receive'
            clicked :: instr.receive(name) #do_it_if_needed(var, "receive") #receive()
            enabled << instr.get_tag(name, 'get_cmd')!=None and not instr.busy
            visible = instr.get_tag(name,'get_cmd')!=None or instr.get_tag(name, 'set_cmd')!=None

template TypedView(base, name, baseType: Float):
    """ A template for Float members"""
    FloatField:
        value :=  getattr(base, name)
        minimum=get_tag(base, name, 'low')
        maximum=get_tag(base, name, 'high')

template TypedView(base, name, baseType: float):
    TypedView(base, name, Float): pass

template ListView(base, name, baseType: Float, Index):
    """ A template for Float members"""
    FloatField:
        value :=  getattr(base, name)[Index.value]
        minimum=get_tag(base, name, 'low')
        maximum=get_tag(base, name, 'high')

template ListView(base, name, baseType: float, Index):
    ListView(base, name, Float, Index): pass

template TypedView(instrin, name, baseType: list):
    PushButton:
        text="list" #TypedView(instrin, name, Base):

template TypedView(instrin, name, baseType: tuple):
    PushButton:
        text="tuple" #TypedView(instrin, name, Base):

class fake(object):
    def fff():
        pass

template TypedView(base, name, baseType: type(fake.fff)):
    TypedView(base, name, Callable): pass

template TypedView(base, name, baseType: Range):
    """ A template for Range members"""
    Container:
        constraints=[hbox(sel, min_lbl, sel_slider, max_lbl)]
        SpinBox: sel:
            value:=getattr(base, name)
            minimum = sel_slider.minimum
            maximum = sel_slider.maximum
        Slider: sel_slider:
            minimum = base.get_member(name).validate_mode[1][0]
            maximum = base.get_member(name).validate_mode[1][1]
            value :=getattr(base, name)
            tracking = False
        Label: min_lbl:
                text << str(sel_slider.minimum)
        Label: max_lbl:
            text << str(sel_slider.maximum)

#template ValView(base, name, baseType: FloatRange):
#    """ A form control template specialization for Float members"""
#    Container:
#        constraints=[hbox(sel, min_lbl, sel_slider, max_lbl)]
#        FloatField: sel:
#            value:=getattr(base, name)
#            minimum = ft.minimum
#            maximum = ft.maximum
#        Slider: sel_slider:
#            tracking = False
#            FloatTransform: ft:
#                minimum=base.get_tag(name, 'low')
#                maximum=base.get_tag(name, 'high')
#                value :=getattr(base, name)
#                precision=base.get_tag(name, 'precision', 100)
#        Label: min_lbl:
#                text << str(ft.minimum)
#        Label: max_lbl:
#            text << str(ft.maximum)

template ListView(Instr, Name, AttrType: Int, Index):
    """ A template for indexed Int members using a spin box"""
    SpinBox:
        value := getattr(Instr, Name)[Index]
        minimum=int(get_tag(Instr, Name, 'low', -2147483648))
        maximum=int(get_tag(Instr, Name, 'high', 2147483647))

template ListView(Instr, Name, AttrType: int, Index):
    ListView(Instr, Name, Int, Index): pass

template TypedView(Instr, Name, AttrType: Int):
    """ A template for Int members using a spin box"""
    SpinBox:
        value := getattr(Instr, Name)
        minimum=int(get_tag(Instr, Name, 'low', -2147483648))
        maximum=int(get_tag(Instr, Name, 'high', 2147483647))

template TypedView(Instr, Name, AttrType: int):
    TypedView(Instr, Name, Int): pass

template TypedView(base, name, baseType: Str):
    """ A template for Str using a MultilineField"""
    MultilineField: mlf:
            text := getattr(base, name)

template TypedView(base, name, baseType: str):
    TypedView(base, name, Str): pass

template TypedView(base, name, baseType: Unicode):
    """A template for Unicode using a field"""
    Field:
        text := getattr(base, name)

template TypedView(base, name, baseType: unicode):
    TypedView(base, name, Unicode): pass

def run_params(base, name):
    try:
        return getattr(base, name).run_params
    except AttributeError, e:
        log_debug("AttributeError: {}".format(e))
        return []

template TypedView(instr, name, baseType: Callable):
    """A template specialization for a Callable using a PushButton"""
    Container:
        padding = 0
        constraints = [hbox(pb1, gb1 ,pb2), align('top', pb1, gb1, pb2)]
        PushButton: pb1:
            text = 'Run'
            clicked ::
                try:
                    getattr(instr, name)(instr) #do_it_if_needed(var, "receive") #receive()
                except TypeError:
                    getattr(instr, name)()
            enabled << not instr.boss.busy
        GroupBox: gb1:
            padding = 0
            visible = run_params(instr, name)!=[]
            title = get_tag(instr, name, 'label', name)+" parameters:"
            Looper: get_loop:
                    iterable << run_params(instr, name)
                    DynamicTemplate:
                        base=VarView
                        args=(instr, loop_item, get_type(instr, loop_item))
        PushButton: pb2:
            text = 'Abort'
            clicked ::
                instr.boss.abort=True
            enabled <<  instr.boss.busy

def get_map(base, name):
    try:
        return base.get_map(name)
    except AttributeError:
        return getattr(base, name)

template TypedView(base, name, baseType: Enum):
    """ A form control template specialization for Enum members using ObjectCombo."""
    Container:
        padding = 0
        constraints = [ hbox(val, enm_val)]
        ObjectCombo: val:
            items = list(base.get_member(name).items)
            selected := getattr(base, name)
            selected :: enm_val.text=unicode(get_map(base, name))
        Label: enm_val:
            text =  unicode(get_map(base, name))

template TypedView(base, name, baseType: Bool):
    """ A template specialization for Bool members using CheckBox"""
    CheckBox:
        checked := getattr(base, name)

template TypedView(base, name, baseType: bool):
    TypedView(base, name, Bool): pass

#template CLView(base, name, index, vtype: Base):
#    AutoFormWrap:
#        instr:=getattr(base, name)[index]
#
#template CLView(base, name, index, vtype):
#    MultilineField:
#        read_only=True
#        text<<unicode(getattr(base, name))
#
##template CLView(base, name, index, vtype: "EMPTY"):
##    pass
#
#template CLView(base, name, index, vtype: float):
#    FloatField:
#        value:=getattr(base, name)[index]
#
#template CLView(base, name, index, vtype: int):
#    IntField:
#        value:=getattr(base, name)[index]
#
#template CLView(base, name, index, vtype: str):
#    """ A template specialization for Unicode using a MultilineField"""
#    MultilineField: mlf:
#            text := getattr(base, name)[index]
#
##template CLView(base, name, index, vtype: list):
##        GroupBox:
##            padding = 0
#            #visible << getattr(base, name)!=[]
#            #title = instr.get_tag(name, 'label', name)+" variables:"
#            #Looper:
#            #        iterable << getattr(base, name) #base.return_vars
#           #         DynamicTemplate:
#           #             base=VarTemp #text = '{0} {1}'.format(loop_index, loop_item)
#           #             args=(loop_item, base, type(base))
#
#template CLView(base, name, index, vtype: unicode):
#    """A template specialization for Unicode using a field"""
#    Field:
#        text := getattr(base, name)[index]
#
#template ClView(base, name, index, vtype: bool):
#    """ A form control template specialization for Bool members using CheckBox"""
#    CheckBox:
#        checked := getattr(base, name)[index]
#
#def get_type(base, name, index):
#    if index<len(getattr(base, name)):
#        print type(getattr(base, name)[index]), base.get_tag(name, "inside_type")
#        return base.get_tag(name, "inside_type", type(getattr(base, name)[index]))
#    return None
#


enamldef iCo(Container):
    attr muv: Unicode
#    attr mv = 0
#    attr rp = "value"
#    mv<< dyn.tagged["value"].value
#     #    if muv!=mv:
#    #        muv=mv
#    alias dyn
#    DynamicTemplate: dyn:
#                base = ListView
#                args << (type(muv),) #, get_type(base, name, ind.value))
#                data << dict(value=muv,)
#                tags = ('value',)


template ListView(AttrType: int):
    """ A template for indexed Int members using a spin box"""

    SpinBox: sb:
            pass
            #attr mv
            #value:=mv
            #value :: mye()
            #value := getattr(Instr, Name)[Index]
            #minimum=int(get_tag(Instr, Name, 'low', -2147483648))
            #maximum=int(get_tag(Instr, Name, 'high', 2147483647))

template TypedView(instrin, name, baseType: ContainerList):
    Container: cc:
        attr rp = "value"
#        attr muvy = getattr(instrin, name)[ind.value]
 #       muvy<< val.dyn.tagged["pluto"][0].value
  #      muvy:: print val.dyn.tagged
        #val.mv:: print "change"
        #    if getattr(instrin, name)[ind.value]!=cc.muv:
        #        getattr(instrin, name)[ind.value]=cc.muv
        padding=0
        constraints = [hbox(ind, val, insert_btn, pop_btn), ind.width==100]
        SpinBox: ind:
            minimum=0
            maximum << max(0, len(getattr(instrin, name))-1)
        Container: val:
            padding = 0
            #attr muv<<getattr(instrin, name)[ind.value]
            #mv::
            #    print dyn.tagged
            #    if getattr(instrin, name)[ind.value]!=val.mv:
            #        getattr(instrin, name)[ind.value]=val.mv

            #dyn.tagged["value"].value :: print"value changed"
            alias dyn
            DynamicTemplate: dyn:

                base = ListView
                args << (type(getattr(instrin, name)[ind.value]),) #, get_type(base, name, ind.value))
                data << {rp:getattr(instrin, name)[ind.value]}
                startag="pluto"
                data::print dir(dyn) #tagged
                startag::print startag
                tags=("value.value",)
                #dyn.tagged["pluto"][0.value]::print tagged
            #    tags = ('value',)
                #tagged:: print "cahnge" #>>getattr(instrin, name)[ind.value]
        #iCo:
        #    muv<< unicode(getattr(val.dyn.tagged["pluto"][0], rp))
        #    muv::print "stuff"
        PushButton: insert_btn:
            #text<< unicode(getattr(val.dyn.tagged["pluto"][0], rp))
            #text::
            #    if getattr(instrin, name)[ind.value]!=getattr(val.dyn.tagged["pluto"][0], rp):
            #        getattr(instrin, name)[ind.value]=getattr(val.dyn.tagged["pluto"][0], rp)
            #    print val.dyn.tags, val.dyn.startag, val.dyn.tagged, val.dyn.tagged["pluto"][0].value
#                #dyn.tags, val.dyn.startag, val.dyn.tagged
            clicked::
                print val.dyn.tags, val.dyn.startag, val.dyn.tagged, val.dyn.tagged["pluto"][0].value
#                if len(getattr(base, name))==0:
#                    intype=base.get_tag(name, 'inside_type')() #if inside_type is not specified for an empty array, this will generate an error
#                else:
#                    temptype=getattr(base, name)[ind.value]
#                    if isinstance(temptype, Base):
#                        intype=temptype.copy()
#                    else:
#                        intype=type(temptype)()
#                getattr(base, name).insert(ind.value, intype) #pass #mydata.insert()
#            #visible << base.get_tag(name, "full_interface", False)
        PushButton: pop_btn:
            text<<"Remove"
            clicked:: getattr(instrin, name).pop(ind.value)
#            #visible << base.get_tag(name, "full_interface", False)
            enabled << len(getattr(instrin, name))>0
#
#template TypedView(base, name, baseType: Int, Index = None):
#
#    """ A template for Int members using a spin box"""
#
#    #Conditional:
#    #    condition = Index is None
#    IndexContent(SpinBox): sp:
#            alias content
#            sp.content.value := sp.content.myval
#            sp.content.minimum=int(get_tag(base, name, 'low', -2147483648))
#            sp.content.maximum=int(get_tag(base, name, 'high', 2147483647))



template TypedView(Instr, Name, baseType: List):
        GroupBox:
            padding = 0
            visible << getattr(Instr, Name)!=[]
            title = Instr.get_tag(Name, 'label', Name)+" variables:"
            Form:
                SpinBox: ind:
                    minimum = 0
                    maximum << len(getattr(Instr, Name))-1
                DynamicTemplate:
                    base=ListView
                    args=(Instr, Name, type(getattr(Instr, Name)[ind.value]), ind)
